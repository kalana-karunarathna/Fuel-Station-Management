// utils/pdfGenerator.js
const PDFDocument = require('pdfkit');
const moment = require('moment');

/**
 * Generate a PDF report from the given data
 * @param {Object} reportData - Report data to be included in the PDF
 * @returns {Promise<Buffer>} - Promise resolving to PDF buffer
 */
const generatePDFReport = (reportData) => {
  return new Promise((resolve, reject) => {
    try {
      // Create a PDF document
      const doc = new PDFDocument({ margin: 50 });
      
      // Buffer to store PDF data
      const buffers = [];
      doc.on('data', buffers.push.bind(buffers));
      
      // When document is done being written, resolve promise with the PDF data
      doc.on('end', () => {
        const pdfData = Buffer.concat(buffers);
        resolve(pdfData);
      });

      // Add header
      addHeader(doc, reportData);

      // Add content based on report type
      addReportContent(doc, reportData);

      // Add footer
      addFooter(doc, reportData);

      // Finalize the PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
};

/**
 * Add header to the PDF document
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addHeader = (doc, reportData) => {
  // Add title
  doc.fontSize(20)
     .font('Helvetica-Bold')
     .text('Fuel Station Management System', { align: 'center' })
     .moveDown(0.5);
  
  // Add report type
  doc.fontSize(16)
     .text(reportData.reportType || 'Report', { align: 'center' })
     .moveDown(1);
  
  // Add company info
  doc.fontSize(10)
     .font('Helvetica')
     .text('ABC Fuel Station Ltd.')
     .text('123 Fuel Lane, Colombo, Sri Lanka')
     .text('Tel: +94 11 234 5678')
     .text('Email: info@abcfuelstation.com')
     .moveDown(1);
  
  // Add report period
  if (reportData.period) {
    const startDate = moment(reportData.period.startDate).format('MMM DD, YYYY');
    const endDate = moment(reportData.period.endDate).format('MMM DD, YYYY');
    
    doc.text(`Report Period: ${startDate} to ${endDate}`)
       .moveDown(0.5);
  }
  
  // Add generation info
  if (reportData.generatedAt) {
    doc.text(`Generated on: ${moment(reportData.generatedAt).format('MMM DD, YYYY HH:mm:ss')}`)
       .moveDown(0.5);
  }
  
  if (reportData.generatedBy) {
    doc.text(`Generated by: ${reportData.generatedBy}`)
       .moveDown(0.5);
  }
  
  // Add a horizontal line
  doc.moveTo(50, doc.y)
     .lineTo(doc.page.width - 50, doc.y)
     .stroke()
     .moveDown(1);
};

/**
 * Add content to the PDF document based on report type
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addReportContent = (doc, reportData) => {
  // Add summary section if available
  if (reportData.summary) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Summary', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Add summary items
    Object.entries(reportData.summary).forEach(([key, value]) => {
      // Format the key nicely
      const formattedKey = key
        .replace(/([A-Z])/g, ' $1')
        .replace(/^./, str => str.toUpperCase())
        .replace(/([a-z])([A-Z])/g, '$1 $2');
      
      // Format value based on its type
      let formattedValue = value;
      if (typeof value === 'number') {
        // Format as currency if it looks like a monetary value
        if (key.toLowerCase().includes('amount') || 
            key.toLowerCase().includes('total') || 
            key.toLowerCase().includes('balance') || 
            key.toLowerCase().includes('price')) {
          formattedValue = `LKR ${value.toFixed(2)}`;
        } else if (key.toLowerCase().includes('percentage')) {
          formattedValue = `${value.toFixed(2)}%`;
        }
      }
      
      doc.text(`${formattedKey}: ${formattedValue}`, { continued: false });
    });
    
    doc.moveDown(1);
  }
  
  // Add different sections based on report type
  if (reportData.reportType) {
    // Sales Report
    if (reportData.reportType.includes('Sales')) {
      addSalesReportContent(doc, reportData);
    }
    // Financial Report
    else if (reportData.reportType.includes('Profit') || 
             reportData.reportType.includes('Cash Flow') || 
             reportData.reportType.includes('Expense') || 
             reportData.reportType.includes('Revenue') ||
             reportData.reportType.includes('Tax')) {
      addFinancialReportContent(doc, reportData);
    }
    // Inventory Report
    else if (reportData.reportType.includes('Inventory') || 
             reportData.reportType.includes('Stock') || 
             reportData.reportType.includes('Fuel')) {
      addInventoryReportContent(doc, reportData);
    }
    // Customer Report
    else if (reportData.reportType.includes('Customer') || 
             reportData.reportType.includes('Credit') || 
             reportData.reportType.includes('Invoice')) {
      addCustomerReportContent(doc, reportData);
    }
    // Banking Report
    else if (reportData.reportType.includes('Bank') || 
             reportData.reportType.includes('Cash') || 
             reportData.reportType.includes('Transaction')) {
      addBankingReportContent(doc, reportData);
    }
  }
};

/**
 * Add sales report specific content to the PDF
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addSalesReportContent = (doc, reportData) => {
  // Sales by Fuel Type
  if (reportData.salesByFuelType || reportData.revenueByFuelType) {
    const fuelTypeData = reportData.salesByFuelType || reportData.revenueByFuelType;
    
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Sales by Fuel Type', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [150, 100, 100, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Fuel Type', tableLeft, tableTop)
       .text('Quantity', tableLeft + colWidths[0], tableTop)
       .text('Amount (LKR)', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Count', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('% of Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    // Check if fuelTypeData is an array or object
    const fuelTypes = Array.isArray(fuelTypeData) 
      ? fuelTypeData 
      : Object.keys(fuelTypeData).map(key => ({
          fuelType: key,
          ...fuelTypeData[key]
        }));
    
    fuelTypes.forEach(fuelType => {
      const fuelName = fuelType.fuelType;
      const quantity = fuelType.quantity || 0;
      const amount = fuelType.amount || 0;
      const count = fuelType.count || 0;
      const percentage = fuelType.percentageOfTotal || 0;
      
      doc.text(fuelName, tableLeft, y)
         .text(quantity.toFixed(2), tableLeft + colWidths[0], y)
         .text(amount.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(count.toString(), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${percentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Sales by Payment Method
  if (reportData.salesByPaymentMethod) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Sales by Payment Method', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [150, 100, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Payment Method', tableLeft, tableTop)
       .text('Amount (LKR)', tableLeft + colWidths[0], tableTop)
       .text('Count', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('% of Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    // Check if it's an array or object
    const paymentMethods = Array.isArray(reportData.salesByPaymentMethod) 
      ? reportData.salesByPaymentMethod 
      : Object.keys(reportData.salesByPaymentMethod).map(key => ({
          paymentMethod: key,
          ...reportData.salesByPaymentMethod[key]
        }));
    
    paymentMethods.forEach(method => {
      const methodName = method.paymentMethod;
      const amount = method.amount || 0;
      const count = method.count || 0;
      const percentage = method.percentageOfTotal || 0;
      
      doc.text(methodName, tableLeft, y)
         .text(amount.toFixed(2), tableLeft + colWidths[0], y)
         .text(count.toString(), tableLeft + colWidths[0] + colWidths[1], y)
         .text(`${percentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Sales Trends
  if (reportData.trends || reportData.dailySales || reportData.monthlySales) {
    const trendData = reportData.trends?.daily || reportData.dailySales || reportData.monthlySales;
    
    if (trendData && trendData.length > 0) {
      doc.fontSize(14)
         .font('Helvetica-Bold')
         .text('Sales Trends', { underline: true })
         .moveDown(0.5);
      
      doc.fontSize(10)
         .font('Helvetica');
      
      // Create a table header
      const tableTop = doc.y;
      const tableLeft = 50;
      const colWidths = [100, 100, 100, 100];
      
      // Draw table headers
      doc.font('Helvetica-Bold')
         .text('Date', tableLeft, tableTop)
         .text('Amount (LKR)', tableLeft + colWidths[0], tableTop)
         .text('Quantity', tableLeft + colWidths[0] + colWidths[1], tableTop)
         .text('Count', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
         .moveDown(0.5);
      
      // Draw table rows
      let y = doc.y;
      doc.font('Helvetica');
      
      trendData.forEach(item => {
        const date = item.displayDate || item.date || item.displayMonth || item.month;
        const amount = item.amount || 0;
        const quantity = item.quantity || 0;
        const count = item.count || 0;
        
        doc.text(date, tableLeft, y)
           .text(amount.toFixed(2), tableLeft + colWidths[0], y)
           .text(quantity.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
           .text(count.toString(), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
        
        y += 20;
        
        // Check if we need a new page
        if (y > doc.page.height - 100) {
          doc.addPage();
          y = 50;
        }
      });
      
      doc.moveDown(2);
    }
  }
  
  // Top Customers
  if (reportData.topCustomers) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Top Customers', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [150, 100, 100, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Customer', tableLeft, tableTop)
       .text('Amount (LKR)', tableLeft + colWidths[0], tableTop)
       .text('Quantity', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Count', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('% of Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.topCustomers.forEach(customer => {
      const customerName = customer.name || 'Unknown';
      const amount = customer.amount || customer.totalAmount || 0;
      const quantity = customer.quantity || customer.totalQuantity || 0;
      const count = customer.count || customer.saleCount || 0;
      const percentage = customer.percentageOfTotal || 0;
      
      doc.text(customerName, tableLeft, y)
         .text(amount.toFixed(2), tableLeft + colWidths[0], y)
         .text(quantity.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(count.toString(), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${percentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Transactions details
  if (reportData.transactions && reportData.transactions.length > 0) {
    doc.addPage();
    
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Transactions Detail', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 80, 80, 60, 60, 70, 70];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Sale ID', tableLeft, tableTop)
       .text('Date', tableLeft + colWidths[0], tableTop)
       .text('Fuel Type', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Quantity', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Unit Price', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .text('Payment', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4] + colWidths[5], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.transactions.forEach(tx => {
      doc.text(tx.saleId || '', tableLeft, y)
         .text(moment(tx.date).format('YYYY-MM-DD'), tableLeft + colWidths[0], y)
         .text(tx.fuelType || '', tableLeft + colWidths[0] + colWidths[1], y)
         .text(tx.quantity?.toFixed(2) || '0.00', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(tx.unitPrice?.toFixed(2) || '0.00', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(tx.totalAmount?.toFixed(2) || '0.00', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y)
         .text(tx.paymentMethod || '', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4] + colWidths[5], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
        
        // Redraw header on new page
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text('Sale ID', tableLeft, y - 20)
           .text('Date', tableLeft + colWidths[0], y - 20)
           .text('Fuel Type', tableLeft + colWidths[0] + colWidths[1], y - 20)
           .text('Quantity', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y - 20)
           .text('Unit Price', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y - 20)
           .text('Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y - 20)
           .text('Payment', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4] + colWidths[5], y - 20)
           .font('Helvetica');
      }
    });
    
    doc.moveDown(2);
  }
};

/**
 * Add financial report specific content to the PDF
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addFinancialReportContent = (doc, reportData) => {
  // Profit & Loss
  if (reportData.revenue) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Revenue Details', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica')
       .text(`Total Revenue: LKR ${reportData.revenue.totalRevenue.toFixed(2)}`)
       .moveDown(0.5);
    
    if (reportData.revenue.salesByFuelType) {
      doc.font('Helvetica-Bold')
         .text('Revenue by Fuel Type:')
         .moveDown(0.5);
      
      doc.font('Helvetica');
      
      Object.entries(reportData.revenue.salesByFuelType).forEach(([fuelType, data]) => {
        doc.text(`${fuelType}: LKR ${data.amount.toFixed(2)} (${data.quantity.toFixed(2)} liters)`);
      });
      
      doc.moveDown(1);
    }
    
    // Cost of Sales and Gross Profit
    if (reportData.costOfSales !== undefined && reportData.grossProfit !== undefined) {
      doc.text(`Cost of Sales: LKR ${reportData.costOfSales.toFixed(2)}`)
         .text(`Gross Profit: LKR ${reportData.grossProfit.toFixed(2)}`)
         .text(`Gross Margin: ${reportData.grossMargin.toFixed(2)}%`)
         .moveDown(1);
    }
  }
  
  // Expenses
  if (reportData.expenses) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Expense Details', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    if (reportData.expenses.byCategory) {
      doc.font('Helvetica-Bold')
         .text('Expenses by Category:')
         .moveDown(0.5);
      
      doc.font('Helvetica');
      
      // Create a table for expenses by category
      const tableTop = doc.y;
      const tableLeft = 50;
      const colWidths = [200, 100, 100];
      
      // Draw table headers
      doc.font('Helvetica-Bold')
         .text('Category', tableLeft, tableTop)
         .text('Amount (LKR)', tableLeft + colWidths[0], tableTop)
         .text('% of Total', tableLeft + colWidths[0] + colWidths[1], tableTop)
         .moveDown(0.5);
      
      // Draw table rows
      let y = doc.y;
      doc.font('Helvetica');
      
      Object.entries(reportData.expenses.byCategory).forEach(([category, amount]) => {
        const percentage = amount / reportData.expenses.totalExpenses * 100;
        
        doc.text(category, tableLeft, y)
           .text(amount.toFixed(2), tableLeft + colWidths[0], y)
           .text(`${percentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1], y);
        
        y += 20;
        
        // Check if we need a new page
        if (y > doc.page.height - 100) {
          doc.addPage();
          y = 50;
        }
      });
      
      doc.moveDown(2);
    }
    
    doc.text(`Total Expenses: LKR ${reportData.expenses.totalExpenses.toFixed(2)}`)
       .moveDown(1);
  }
  
  // Net Profit
  if (reportData.netProfit !== undefined) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Net Profit', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica')
       .text(`Net Profit: LKR ${reportData.netProfit.toFixed(2)}`)
       .text(`Net Margin: ${reportData.netMargin.toFixed(2)}%`)
       .moveDown(1);
  }
  
  // Cash Flow
  if (reportData.monthlyBreakdown) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Cash Flow Monthly Breakdown', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [100, 100, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Month', tableLeft, tableTop)
       .text('Inflow (LKR)', tableLeft + colWidths[0], tableTop)
       .text('Outflow (LKR)', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Net Cash Flow', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.monthlyBreakdown.forEach(month => {
      doc.text(month.displayMonth, tableLeft, y)
         .text(month.inflow.toFixed(2), tableLeft + colWidths[0], y)
         .text(month.outflow.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(month.netCashFlow.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Expense Analysis Details
  if (reportData.expensesByCategory) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Expense Analysis', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [150, 100, 80, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Category', tableLeft, tableTop)
       .text('Amount (LKR)', tableLeft + colWidths[0], tableTop)
       .text('Count', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('% of Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.expensesByCategory.forEach(expense => {
      doc.text(expense.category, tableLeft, y)
         .text(expense.amount.toFixed(2), tableLeft + colWidths[0], y)
         .text(expense.count.toString(), tableLeft + colWidths[0] + colWidths[1], y)
         .text(`${expense.percentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Tax Report
  if (reportData.taxLiabilities) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Tax Liabilities', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica')
       .text(`VAT Amount: LKR ${reportData.taxLiabilities.vat.toFixed(2)}`)
       .text(`Income Tax: LKR ${reportData.taxLiabilities.incomeTax.toFixed(2)}`)
       .text(`Total Tax Liability: LKR ${reportData.taxLiabilities.totalTaxLiability.toFixed(2)}`)
       .moveDown(2);
  }
};

/**
 * Add inventory report specific content to the PDF
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addInventoryReportContent = (doc, reportData) => {
  // Inventory by Fuel Type
  if (reportData.byFuelType) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Inventory by Fuel Type', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [100, 100, 100, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Fuel Type', tableLeft, tableTop)
       .text('Total Volume', tableLeft + colWidths[0], tableTop)
       .text('Capacity', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Usage %', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Value (LKR)', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.byFuelType.forEach(fuelType => {
      doc.text(fuelType.fuelType, tableLeft, y)
         .text(fuelType.totalVolume.toFixed(2), tableLeft + colWidths[0], y)
         .text(fuelType.totalCapacity.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(`${fuelType.usagePercentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(fuelType.value.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Inventory Items Detail
  if (reportData.items && reportData.items.length > 0) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Inventory Items Detail', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 80, 70, 70, 70, 80];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Tank ID', tableLeft, tableTop)
       .text('Fuel Type', tableLeft + colWidths[0], tableTop)
       .text('Current Vol.', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Capacity', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Usage %', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('Status', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.items.forEach(item => {
      doc.text(item.tankId, tableLeft, y)
         .text(item.fuelType, tableLeft + colWidths[0], y)
         .text(item.currentVolume.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(item.tankCapacity.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${item.usagePercentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(item.status, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Stock Movements
  if (reportData.movements && reportData.movements.length > 0) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Stock Movements', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 80, 80, 70, 70];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Date', tableLeft, tableTop)
       .text('Tank ID', tableLeft + colWidths[0], tableTop)
       .text('Fuel Type', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Type', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Volume', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.movements.forEach(movement => {
      doc.text(moment(movement.date).format('YYYY-MM-DD'), tableLeft, y)
         .text(movement.tankId, tableLeft + colWidths[0], y)
         .text(movement.fuelType, tableLeft + colWidths[0] + colWidths[1], y)
         .text(movement.type, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(movement.volume.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Low stock alerts
  if (reportData.items && reportData.reportType && reportData.reportType.includes('Low Stock')) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Low Stock Alerts', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 80, 70, 70, 70, 90];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Tank ID', tableLeft, tableTop)
       .text('Fuel Type', tableLeft + colWidths[0], tableTop)
       .text('Current Vol.', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Reorder Level', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Shortfall', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('Recommended', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    // Filter for only low stock items if needed
    const lowStockItems = reportData.items.filter(item => 
      item.reorderLevel && item.currentVolume <= item.reorderLevel
    );
    
    (lowStockItems.length > 0 ? lowStockItems : reportData.items).forEach(item => {
      const shortfall = item.reorderLevel && item.currentVolume < item.reorderLevel ? 
        item.reorderLevel - item.currentVolume : 0;
      
      doc.text(item.tankId, tableLeft, y)
         .text(item.fuelType, tableLeft + colWidths[0], y)
         .text(item.currentVolume.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(item.reorderLevel ? item.reorderLevel.toFixed(2) : 'N/A', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(shortfall.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(item.recommendedTopUp ? item.recommendedTopUp.toFixed(2) : (item.tankCapacity - item.currentVolume).toFixed(2), 
               tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Price Analysis
  if (reportData.priceChanges) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Fuel Price Changes', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 80, 70, 70, 70, 120];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Date', tableLeft, tableTop)
       .text('Fuel Type', tableLeft + colWidths[0], tableTop)
       .text('Old Price', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('New Price', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Change %', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('Reason', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.priceChanges.forEach(change => {
      const percentageChange = ((change.newPrice - change.oldPrice) / change.oldPrice) * 100;
      
      doc.text(moment(change.date).format('YYYY-MM-DD'), tableLeft, y)
         .text(change.fuelType, tableLeft + colWidths[0], y)
         .text(change.oldPrice.toFixed(2), tableLeft + colWidths[0] + colWidths[1], y)
         .text(change.newPrice.toFixed(2), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${percentageChange.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(change.reason || '', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
  }
};

/**
 * Add customer report specific content to the PDF
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addCustomerReportContent = (doc, reportData) => {
  // Customers List
  if (reportData.customers) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Customer List', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [120, 120, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Customer ID', tableLeft, tableTop)
       .text('Name', tableLeft + colWidths[0], tableTop)
       .text('Credit Limit', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Status', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.customers.forEach(customer => {
      doc.text(customer.customerId, tableLeft, y)
         .text(customer.name, tableLeft + colWidths[0], y)
         .text(customer.creditLimit ? `LKR ${customer.creditLimit.toFixed(2)}` : '-', tableLeft + colWidths[0] + colWidths[1], y)
         .text(customer.status, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Outstanding Invoices
  if (reportData.invoices) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Outstanding Invoices', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [90, 90, 70, 70, 70, 60];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Invoice #', tableLeft, tableTop)
       .text('Customer', tableLeft + colWidths[0], tableTop)
       .text('Issue Date', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Due Date', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Amount Due', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('Days Due', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.invoices.forEach(invoice => {
      doc.text(invoice.invoiceNumber, tableLeft, y)
         .text(invoice.customer, tableLeft + colWidths[0], y)
         .text(moment(invoice.issueDate).format('YYYY-MM-DD'), tableLeft + colWidths[0] + colWidths[1], y)
         .text(moment(invoice.dueDate).format('YYYY-MM-DD'), tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`LKR ${invoice.amountDue.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(invoice.daysOverdue.toString(), tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Customer Aging
  if (reportData.customerAging) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Customer Aging Analysis', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [120, 70, 70, 70, 70, 70];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Customer', tableLeft, tableTop)
       .text('Current', tableLeft + colWidths[0], tableTop)
       .text('1-30 Days', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('31-60 Days', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('61-90 Days', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .text('90+ Days', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.customerAging.forEach(customer => {
      doc.text(customer.name, tableLeft, y)
         .text(`LKR ${customer.buckets.current.toFixed(2)}`, tableLeft + colWidths[0], y)
         .text(`LKR ${customer.buckets['1-30'].toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1], y)
         .text(`LKR ${customer.buckets['31-60'].toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`LKR ${customer.buckets['61-90'].toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y)
         .text(`LKR ${customer.buckets['90+'].toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Credit Customers
  if (reportData.reportType && reportData.reportType.includes('Credit Customers')) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Credit Customers', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [120, 80, 80, 80, 80];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Customer', tableLeft, tableTop)
       .text('Credit Limit', tableLeft + colWidths[0], tableTop)
       .text('Current Balance', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Available Credit', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Utilization %', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    // Filter for only credit customers if needed
    const creditCustomers = reportData.customers.filter(customer => 
      customer.creditLimit && customer.creditLimit > 0
    );
    
    (creditCustomers.length > 0 ? creditCustomers : reportData.customers).forEach(customer => {
      const availableCredit = customer.creditLimit - customer.currentBalance;
      const utilizationPercentage = customer.creditLimit > 0 ? 
        (customer.currentBalance / customer.creditLimit) * 100 : 0;
      
      doc.text(customer.name, tableLeft, y)
         .text(`LKR ${customer.creditLimit.toFixed(2)}`, tableLeft + colWidths[0], y)
         .text(`LKR ${customer.currentBalance.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1], y)
         .text(`LKR ${availableCredit.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${utilizationPercentage.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Top Customers
  if (reportData.topCustomers) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Top Customers', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [120, 80, 80, 80, 80];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Customer', tableLeft, tableTop)
       .text('Total Amount', tableLeft + colWidths[0], tableTop)
       .text('Sale Count', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Avg. Sale Amount', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('% of Total', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.topCustomers.forEach(customer => {
      const avgSaleAmount = customer.saleCount > 0 ? 
        customer.totalAmount / customer.saleCount : 0;
      
      doc.text(customer.name, tableLeft, y)
         .text(`LKR ${customer.totalAmount.toFixed(2)}`, tableLeft + colWidths[0], y)
         .text(customer.saleCount.toString(), tableLeft + colWidths[0] + colWidths[1], y)
         .text(`LKR ${avgSaleAmount.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`${customer.percentageOfTotal.toFixed(2)}%`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
  }
};

/**
 * Add banking report specific content to the PDF
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addBankingReportContent = (doc, reportData) => {
  // Bank Accounts Summary
  if (reportData.accounts) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Bank Accounts Summary', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [100, 120, 100, 100];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Account ID', tableLeft, tableTop)
       .text('Bank & Account #', tableLeft + colWidths[0], tableTop)
       .text('Current Balance', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Available Credit', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.accounts.forEach(account => {
      doc.text(account.accountId, tableLeft, y)
         .text(`${account.bankName} - ${account.accountNumber}`, tableLeft + colWidths[0], y)
         .text(`LKR ${account.currentBalance.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1], y)
         .text(account.availableCredit ? `LKR ${account.availableCredit.toFixed(2)}` : '-', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Bank Transactions
  if (reportData.transactions) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Bank Transactions', { underline: true })
       .moveDown(0.5);
    
    doc.fontSize(10)
       .font('Helvetica');
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 120, 60, 80, 80];
    
    // Draw table headers
    doc.font('Helvetica-Bold')
       .text('Date', tableLeft, tableTop)
       .text('Description', tableLeft + colWidths[0], tableTop)
       .text('Type', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Amount', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Balance', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.transactions.forEach(tx => {
      doc.text(moment(tx.date).format('YYYY-MM-DD'), tableLeft, y)
         .text(tx.description, tableLeft + colWidths[0], y)
         .text(tx.type, tableLeft + colWidths[0] + colWidths[1], y)
         .text(`LKR ${tx.amount.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`LKR ${tx.balanceAfterTransaction.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
    
    doc.moveDown(2);
  }
  
  // Petty Cash Report
  if (reportData.stationBalances || reportData.transactions) {
    if (reportData.stationBalances) {
      doc.fontSize(14)
         .font('Helvetica-Bold')
         .text('Petty Cash Balances', { underline: true })
         .moveDown(0.5);
      
      doc.fontSize(10)
         .font('Helvetica');
      
      // Create a table header
      const tableTop = doc.y;
      const tableLeft = 50;
      const colWidths = [100, 100, 100, 100];
      
      // Draw table headers
      doc.font('Helvetica-Bold')
         .text('Station ID', tableLeft, tableTop)
         .text('Current Balance', tableLeft + colWidths[0], tableTop)
         .text('Min Limit', tableLeft + colWidths[0] + colWidths[1], tableTop)
         .text('Max Limit', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
         .moveDown(0.5);
      
      // Draw table rows
      let y = doc.y;
      doc.font('Helvetica');
      
      reportData.stationBalances.forEach(station => {
        doc.text(station.stationId, tableLeft, y)
           .text(`LKR ${station.currentBalance.toFixed(2)}`, tableLeft + colWidths[0], y)
           .text(`LKR ${station.minLimit.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1], y)
           .text(`LKR ${station.maxLimit.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y);
        
        y += 20;
        
        // Check if we need a new page
        if (y > doc.page.height - 100) {
          doc.addPage();
          y = 50;
        }
      });
      
      doc.moveDown(2);
    }
  }
  
  // Reconciliation Report
  if (reportData.byAccount && reportData.unreconciledTransactions) {
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Bank Reconciliation Report', { underline: true })
       .moveDown(0.5);
    
    // Add summary table
    doc.fontSize(10)
       .font('Helvetica');
    
    if (reportData.summary) {
      doc.font('Helvetica-Bold')
         .text('Reconciliation Summary:')
         .moveDown(0.5);
      
      doc.font('Helvetica')
         .text(`Total Transactions: ${reportData.summary.totalTransactions}`)
         .text(`Reconciled Transactions: ${reportData.summary.reconciledCount} (${reportData.summary.reconciledPercentage.toFixed(2)}%)`)
         .text(`Unreconciled Transactions: ${reportData.summary.unreconciledCount}`)
         .text(`Reconciled Amount: LKR ${reportData.summary.reconciledAmount.toFixed(2)}`)
         .text(`Unreconciled Amount: LKR ${reportData.summary.unreconciledAmount.toFixed(2)}`)
         .moveDown(1);
    }
    
    // Add account-by-account reconciliation
    doc.fontSize(12)
       .font('Helvetica-Bold')
       .text('Reconciliation by Account')
       .moveDown(0.5);
    
    reportData.byAccount.forEach(account => {
      doc.fontSize(10)
         .font('Helvetica-Bold')
         .text(`Account: ${account.accountName}`)
         .moveDown(0.3);
      
      doc.font('Helvetica')
         .text(`Total Transactions: ${account.totalCount}`)
         .text(`Reconciled: ${account.reconciledCount} (LKR ${account.reconciledAmount.toFixed(2)})`)
         .text(`Unreconciled: ${account.unreconciledCount} (LKR ${account.unreconciledAmount.toFixed(2)})`)
         .moveDown(1);
    });
    
    // Add unreconciled transactions
    doc.fontSize(12)
       .font('Helvetica-Bold')
       .text('Unreconciled Transactions')
       .moveDown(0.5);
    
    // Create a table header
    const tableTop = doc.y;
    const tableLeft = 50;
    const colWidths = [80, 100, 120, 70, 80];
    
    // Draw table headers
    doc.fontSize(10)
       .font('Helvetica-Bold')
       .text('Date', tableLeft, tableTop)
       .text('Transaction ID', tableLeft + colWidths[0], tableTop)
       .text('Description', tableLeft + colWidths[0] + colWidths[1], tableTop)
       .text('Type', tableLeft + colWidths[0] + colWidths[1] + colWidths[2], tableTop)
       .text('Amount', tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], tableTop)
       .moveDown(0.5);
    
    // Draw table rows
    let y = doc.y;
    doc.font('Helvetica');
    
    reportData.unreconciledTransactions.forEach(tx => {
      doc.text(moment(tx.date).format('YYYY-MM-DD'), tableLeft, y)
         .text(tx.transactionId || '', tableLeft + colWidths[0], y)
         .text(tx.description, tableLeft + colWidths[0] + colWidths[1], y)
         .text(tx.type, tableLeft + colWidths[0] + colWidths[1] + colWidths[2], y)
         .text(`LKR ${tx.amount.toFixed(2)}`, tableLeft + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
      
      y += 20;
      
      // Check if we need a new page
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }
    });
  }
};

/**
 * Add footer to the PDF document
 * @param {PDFDocument} doc - PDF document
 * @param {Object} reportData - Report data
 */
const addFooter = (doc, reportData) => {
  const pageCount = doc.bufferedPageRange().count;
  
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    
    // Save the current position
    const originalY = doc.y;
    
    // Position at the bottom of the page
    doc.fontSize(8)
       .font('Helvetica')
       .text(
         `Generated by Fuel Station Management System | ${moment().format('YYYY-MM-DD HH:mm:ss')} | Page ${i + 1} of ${pageCount}`,
         50,
         doc.page.height - 50,
         { width: doc.page.width - 100, align: 'center' }
       );
    
    // Restore original position
    doc.y = originalY;
  }
};

module.exports = { generatePDFReport };